import os
import requests
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from colorama import Fore, Style, init
import time
from report_generator import ReportGenerator

init(autoreset=True)

PAYLOADS_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), "payloads")

def load_payloads(filename):
    path = os.path.join(PAYLOADS_DIR, filename)
    try:
        with open(path, "r", encoding="utf-8") as f:
            return [line.strip() for line in f if line.strip()]
    except Exception as e:
        print(f"Error loading payloads from {path}: {e}")
        return []

class Scanner:
    def __init__(self, urls, blacklist=None, whitelist=None, verbose=True):
        self.urls = urls
        self.blacklist = blacklist or []
        self.whitelist = whitelist or []
        self.verbose = verbose
        self.stats = {"sql": 0, "xss": 0, "lfi": 0, "redirect": 0}
        self.results = {}

    def filter_urls(self):
        filtered = []
        for url in self.urls:
            if self.whitelist and not any(w in url for w in self.whitelist):
                continue
            if any(b in url for b in self.blacklist):
                continue
            filtered.append(url)
        return filtered

    def scan(self, vuln_type="all", report_file=None):
        self.results = {}
        filtered_urls = self.filter_urls()
        try:
            for url in filtered_urls:
                vulnerabilities = []
                interrupted = False
                try:
                    if vuln_type in ["sql", "all"]:
                        res = self.check_sql_injection(url)
                        if res:
                            self.stats["sql"] += len(res)
                            vulnerabilities += res
                    if vuln_type in ["xss", "all"]:
                        res = self.check_xss(url)
                        if res:
                            self.stats["xss"] += len(res)
                            vulnerabilities += res
                    if vuln_type in ["lfi", "all"]:
                        res = self.check_lfi(url)
                        if res:
                            self.stats["lfi"] += len(res)
                            vulnerabilities += res
                    if vuln_type in ["redirect", "all"]:
                        res = self.check_open_redirect(url)
                        if res:
                            self.stats["redirect"] += len(res)
                            vulnerabilities += res
                except KeyboardInterrupt:
                    interrupted = True
                finally:
                    if vulnerabilities:
                        print(f"Adding vulnerabilities for {url}: {vulnerabilities}")
                        self.results[url] = vulnerabilities
                    if report_file:
                        ReportGenerator(self.results).generate_report(report_file)
                    if interrupted:
                        print("\nScan interrupted! Saving partial results...")
                        print("Partial results at interrupt:", self.results)
                        raise KeyboardInterrupt
        except KeyboardInterrupt:
            raise
        return self.results

    def inject_and_request(self, url, payloads, check_func):
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        found = []
        for param in params:
            for payload in payloads:
                test_params = params.copy()
                test_params[param] = [payload]
                new_query = urlencode(test_params, doseq=True)
                test_url = urlunparse(parsed._replace(query=new_query))
                print(Fore.CYAN + f"Testing {test_url} (param: {param}, payload: {payload})")
                result = check_func(test_url, payload)
                if result:
                    print(Fore.RED + f"  [VULNERABLE] {result} in parameter '{param}' with payload '{payload}'")
                    found.append(f"{result} in parameter '{param}' with payload '{payload}'")
                else:
                    print(Fore.GREEN + f"  [NOT VULNERABLE] param '{param}' with payload '{payload}'")
        return found

    def check_sql_injection(self, url):
        sqli_payloads = load_payloads("sqli.txt")
        return self.inject_and_request(url, sqli_payloads, self._check_sql_response)

    def _check_sql_response(self, test_url, payload):
        try:
            start = time.time()
            response = requests.get(test_url, timeout=10)
            elapsed = time.time() - start
            error_signatures = [
                "sql syntax", "mysql", "syntax error", "unclosed quotation mark",
                "you have an error", "warning", "ORA-", "SQLite", "PG::SyntaxError"
            ]
            if any(err in response.text.lower() for err in error_signatures):
                return "Possible SQL Injection vulnerability (error-based)"
            if "sleep" in payload or "delay" in payload or "benchmark" in payload:
                if elapsed > 5:
                    return "Possible SQL Injection vulnerability (time-based)"
        except Exception:
            pass
        return None

    def check_xss(self, url):
        xss_payloads = load_payloads("xss.txt")
        return self.inject_and_request(url, xss_payloads, self._check_xss_response)

    def _check_xss_response(self, test_url, payload):
        try:
            response = requests.get(test_url, timeout=5)
            if payload in response.text:
                return "Possible XSS vulnerability"
        except Exception:
            pass
        return None

    def check_lfi(self, url):
        lfi_payloads = load_payloads("lfi.txt")
        return self.inject_and_request(url, lfi_payloads, self._check_lfi_response)

    def _check_lfi_response(self, test_url, payload):
        try:
            response = requests.get(test_url, timeout=5)
            if "root:x:" in response.text or "[extensions]" in response.text or "boot loader" in response.text:
                return "Possible Local File Inclusion (LFI) vulnerability"
        except Exception:
            pass
        return None

    def check_open_redirect(self, url):
        redirect_payloads = load_payloads("redirect.txt")
        return self.inject_and_request(url, redirect_payloads, self._check_redirect_response)

    def _check_redirect_response(self, test_url, payload):
        try:
            response = requests.get(test_url, allow_redirects=False, timeout=5)
            if response.status_code in [301, 302, 303, 307, 308]:
                location = response.headers.get("Location", "")
                if payload in location:
                    return "Possible Open Redirect vulnerability"
        except Exception:
            pass
        return None

    def export_urls(self, filename="urls.txt"):
        with open(filename, "w") as f:
            for url in self.urls:
                f.write(url + "\n")
        print(Fore.CYAN + f"Exported {len(self.urls)} URLs to {filename}")

    def print_summary(self):
        print(Style.BRIGHT + "\n--- Vulnerability Scan Summary ---")
        print(f"SQL Injection: {self.stats['sql']}")
        print(f"XSS:           {self.stats['xss']}")
        print(f"LFI:           {self.stats['lfi']}")
        print(f"Open Redirect: {self.stats['redirect']}")
        print(f"Total URLs scanned: {len(self.urls)}")